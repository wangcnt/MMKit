组件化架构的路由器部分：

传统的构架：

   最初的客户端架构一般是一个项目一个工程，一个工程里有n个模块。

   如果是小项目尚可，但如果是大型项目，或者各模块之间的难易程度，进度差异经常会导致项目的延期，
   形容形成这样的局面，就是“一个老鼠坏一锅汤”，这在项目的交付上会造成很大的影响。

这时组件化开发的需求就出来了，主要需求就是：

   去掉模块与模块之间的强关联关系，可以在开发过程中各组件只用关心各组件的业务，到交付期时，如有
   模块未完成，可延期，将会其它已经完成的组件。

那么，如何实现呢？

   我们在此参考NSURL的方式，其实客户端与服务器就是一个组件化的实例，客户端当然不能传MMBundle
   这样的类给服务器，服务器也当然不能返回com.markwong.halo.InvitationAction这样的类给客户
   端，因为传输层，网络层，数据层，物理层根本不会识别，它们之间要实现交互，必须采用基本数据类型
   ，比如数字，字符串，客户端或服务器接收到数据后自行根本基本数据类型再转化为平台相关的类与对象。

   同理，在客户端内部组件之间要实现组件化，也需要做一个中间件，也就是路由器，这个路由器当然只是
   传输数据，不做任何的业务逻辑，自然也就闭开了与其它任务组件的强关联，只是为了根据请求方发出的
   资源定位符URI可以定位到目标组件的某个接口。与网络请求NSURL不同的是，NSURL只能传基本数据类型，
   但客户端组件化的URI却可以携带任意系统自带类型由请求方A发送给响应方B，B也将可以回调给请求方
   任意系统自带类型的数据，如果传了非系统自带类型的数据，势必会又要造成强引用了；

因此，组件化的重要原则：
   1. 组成部分：
      1.1. 一个全局资源路由器Accessor；
      1.2. 每个组件的资源标识符URI；
      1.3. 每个组件提供出来的接口类；
      1.4. BundleDelegate，及其相关的接口文档；
   2. Accessor作为数据传输层，不涉及业务，否则会形成强引用关系；
   3. 请求方与响应方所传的数据必须是系统自带类型的数据。

